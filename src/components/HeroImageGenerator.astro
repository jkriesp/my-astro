---
interface Props {
  title: string;
  slug?: string;
  tags?: string[];
}

const { title, slug = '', tags = [] } = Astro.props;

// Simple hash function for deterministic randomness
function hashCode(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

// Seeded random number generator
class SeededRandom {
  private seed: number;

  constructor(seed: number) {
    this.seed = seed;
  }

  next(): number {
    this.seed = (this.seed * 9301 + 49297) % 233280;
    return this.seed / 233280;
  }

  range(min: number, max: number): number {
    return min + this.next() * (max - min);
  }

  int(min: number, max: number): number {
    return Math.floor(this.range(min, max));
  }
}

// Generate seed from title + slug
const seed = hashCode(title + slug + tags.join(''));
const rng = new SeededRandom(seed);

// Color schemes based on accent colors
const colorSchemes = [
  // Blue/Cyan theme
  ['#3b82f6', '#06b6d4', '#0ea5e9', '#6366f1'],
  // Purple/Pink theme
  ['#8b5cf6', '#a855f7', '#ec4899', '#d946ef'],
  // Green/Emerald theme
  ['#10b981', '#059669', '#14b8a6', '#22c55e'],
  // Orange/Amber theme
  ['#f59e0b', '#f97316', '#fb923c', '#fbbf24'],
  // Red/Rose theme
  ['#ef4444', '#f43f5e', '#fb7185', '#dc2626'],
];

const schemeIndex = rng.int(0, colorSchemes.length);
const colors = colorSchemes[schemeIndex];

// Choose pattern type based on seed
const patternType = rng.int(0, 4);

// Generate shapes based on pattern type
function generatePattern(): string {
  let shapes = '';

  switch(patternType) {
    case 0: // Circles
      for (let i = 0; i < 12; i++) {
        const cx = rng.range(0, 1200);
        const cy = rng.range(0, 630);
        const r = rng.range(40, 200);
        const color = colors[rng.int(0, colors.length)];
        const opacity = rng.range(0.1, 0.3);
        shapes += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${color}" opacity="${opacity}" />`;
      }
      break;

    case 1: // Triangles
      for (let i = 0; i < 10; i++) {
        const x1 = rng.range(0, 1200);
        const y1 = rng.range(0, 630);
        const x2 = x1 + rng.range(-150, 150);
        const y2 = y1 + rng.range(-150, 150);
        const x3 = x1 + rng.range(-150, 150);
        const y3 = y1 + rng.range(-150, 150);
        const color = colors[rng.int(0, colors.length)];
        const opacity = rng.range(0.15, 0.35);
        shapes += `<polygon points="${x1},${y1} ${x2},${y2} ${x3},${y3}" fill="${color}" opacity="${opacity}" />`;
      }
      break;

    case 2: // Rectangles
      for (let i = 0; i < 15; i++) {
        const x = rng.range(0, 1200);
        const y = rng.range(0, 630);
        const width = rng.range(50, 250);
        const height = rng.range(50, 250);
        const color = colors[rng.int(0, colors.length)];
        const opacity = rng.range(0.1, 0.3);
        const rotation = rng.range(0, 360);
        shapes += `<rect x="${x}" y="${y}" width="${width}" height="${height}" fill="${color}" opacity="${opacity}" transform="rotate(${rotation} ${x + width/2} ${y + height/2})" />`;
      }
      break;

    case 3: // Waves/Lines
      for (let i = 0; i < 8; i++) {
        const startY = rng.range(0, 630);
        const amplitude = rng.range(50, 150);
        const frequency = rng.range(2, 5);
        const color = colors[rng.int(0, colors.length)];
        const opacity = rng.range(0.15, 0.35);

        let path = `M 0 ${startY}`;
        for (let x = 0; x <= 1200; x += 20) {
          const y = startY + Math.sin(x / (200 / frequency)) * amplitude;
          path += ` L ${x} ${y}`;
        }
        path += ` L 1200 630 L 0 630 Z`;

        shapes += `<path d="${path}" fill="${color}" opacity="${opacity}" />`;
      }
      break;
  }

  return shapes;
}

// Generate gradient background
const gradientAngle = rng.range(0, 360);
const bgColor1 = colors[0];
const bgColor2 = colors[1];

const pattern = generatePattern();
---

<svg
  class="hero-image-generated"
  viewBox="0 0 1200 630"
  xmlns="http://www.w3.org/2000/svg"
  preserveAspectRatio="xMidYMid slice"
>
  <defs>
    <linearGradient id={`bg-gradient-${seed}`} x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style={`stop-color:${bgColor1};stop-opacity:0.15`} />
      <stop offset="100%" style={`stop-color:${bgColor2};stop-opacity:0.15`} />
    </linearGradient>
  </defs>

  <!-- Background -->
  <rect width="1200" height="630" fill="var(--background-secondary)" />
  <rect width="1200" height="630" fill={`url(#bg-gradient-${seed})`} />

  <!-- Pattern -->
  <g>
    <Fragment set:html={pattern} />
  </g>

  <!-- Overlay gradient for depth -->
  <rect width="1200" height="630" fill="url(#overlay-gradient)" opacity="0.3" />
  <defs>
    <linearGradient id="overlay-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#000000;stop-opacity:0" />
      <stop offset="100%" style="stop-color:#000000;stop-opacity:0.4" />
    </linearGradient>
  </defs>
</svg>

<style>
  .hero-image-generated {
    width: 100%;
    height: auto;
    display: block;
  }
</style>
